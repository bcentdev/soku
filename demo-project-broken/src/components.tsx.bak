// React-like TSX Component Demo for Ultra Bundler

interface ButtonProps {
    text: string;
    onClick: () => void;
    disabled?: boolean;
    variant?: 'primary' | 'secondary';
}

export const Button = ({ text, onClick, disabled = false, variant = 'primary' }: ButtonProps) => {
    const className = `btn btn-${variant} ${disabled ? 'btn-disabled' : ''}`;

    return (
        <button
            className={className}
            onClick={onClick}
            disabled={disabled}
            type="button"
        >
            {text}
        </button>
    );
};

interface CounterProps {
    initialCount?: number;
    onCountChange?: (count: number) => void;
}

export const Counter = ({ initialCount = 0, onCountChange }: CounterProps) => {
    const [count, setCount] = useState(initialCount);

    const handleIncrement = () => {
        const newCount = count + 1;
        setCount(newCount);
        onCountChange?.(newCount);
    };

    const handleDecrement = () => {
        const newCount = count - 1;
        setCount(newCount);
        onCountChange?.(newCount);
    };

    return (
        <div className="counter">
            <h3>Counter Component</h3>
            <div className="counter-display">
                <span className="count-value">{count}</span>
            </div>
            <div className="counter-controls">
                <Button
                    text="-"
                    onClick={handleDecrement}
                    variant="secondary"
                />
                <Button
                    text="+"
                    onClick={handleIncrement}
                    variant="primary"
                />
            </div>
        </div>
    );
};

interface UserCardProps {
    user: {
        id: number;
        name: string;
        email: string;
        avatar?: string;
    };
    onEdit?: (userId: number) => void;
}

export const UserCard = ({ user, onEdit }: UserCardProps) => {
    return (
        <div className="user-card">
            <div className="user-avatar">
                {user.avatar ? (
                    <img src={user.avatar} alt={`${user.name} avatar`} />
                ) : (
                    <div className="avatar-placeholder">
                        {user.name.charAt(0).toUpperCase()}
                    </div>
                )}
            </div>
            <div className="user-info">
                <h4 className="user-name">{user.name}</h4>
                <p className="user-email">{user.email}</p>
                {onEdit && (
                    <Button
                        text="Edit"
                        onClick={() => onEdit(user.id)}
                        variant="secondary"
                    />
                )}
            </div>
        </div>
    );
};

// Higher-order component example (simplified)
export function withLoading<T>(Component: any) {
    return (props: T & { isLoading?: boolean }) => {
        if (props.isLoading) {
            return <div className="loading">Loading...</div>;
        }
        return <Component {...props} />;
    };
}

// Generic component
interface ListProps<T> {
    items: T[];
    renderItem: (item: T, index: number) => JSX.Element;
    emptyMessage?: string;
}

export function List<T>({ items, renderItem, emptyMessage = "No items" }: ListProps<T>) {
    if (items.length === 0) {
        return <div className="empty-list">{emptyMessage}</div>;
    }

    return (
        <ul className="list">
            {items.map((item, index) => (
                <li key={index} className="list-item">
                    {renderItem(item, index)}
                </li>
            ))}
        </ul>
    );
}

// Simulated useState hook for demo (normally from React)
function useState<T>(initialValue: T): [T, (value: T) => void] {
    let value = initialValue;
    const setValue = (newValue: T) => {
        value = newValue;
        // In real React, this would trigger re-render
    };
    return [value, setValue];
}